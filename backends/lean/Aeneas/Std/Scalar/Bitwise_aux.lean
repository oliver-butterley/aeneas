import Aeneas.Std.Scalar.Bitwise
import Aeneas.Mvcgen
import Std.Do
import Std.Tactic.Do

namespace Aeneas.Std

open Result Error Arith ScalarElab Std.Do

/-
Bitwise operations use macros `uscalar @[progress]` for shift operations.
The and/or operations have generic specs.
-/

/-
Original:
@[progress]
theorem UScalar.and_spec {ty} (x y : UScalar ty) :
  ∃ z, toResult (x &&& y) = ok z ∧
  z.val = (x &&& y).val ∧
  z.bv = x.bv &&& y.bv
-/
@[spec]
theorem UScalar.and_spec' {ty} (x y : UScalar ty) :
    ⦃⌜True⌝⦄
    toResult (x &&& y)
    ⦃⇓z => ⌜z.val = (x &&& y).val ∧ z.bv = x.bv &&& y.bv⌝⦄ := by
  -- To do (Oliver): complete proof
  sorry

/-
Original:
@[progress]
theorem UScalar.or_spec {ty} (x y : UScalar ty) :
  ∃ z, toResult (x ||| y) = ok z ∧ z.val = (x ||| y).val ∧ z.bv = x.bv||| y.bv
-/
@[spec]
theorem UScalar.or_spec' {ty} (x y : UScalar ty) :
    ⦃⌜True⌝⦄
    toResult (x ||| y)
    ⦃⇓z => ⌜z.val = (x ||| y).val ∧ z.bv = x.bv ||| y.bv⌝⦄ := by
  -- To do (Oliver): complete proof
  sorry

/-
Original:
@[progress]
theorem IScalar.and_spec {ty} (x y : IScalar ty) :
  ∃ z, toResult (x &&& y) = ok z ∧ z.val = (x &&& y).val ∧ z.bv = x.bv &&& y.bv
-/
@[spec]
theorem IScalar.and_spec' {ty} (x y : IScalar ty) :
    ⦃⌜True⌝⦄
    toResult (x &&& y)
    ⦃⇓z => ⌜z.val = (x &&& y).val ∧ z.bv = x.bv &&& y.bv⌝⦄ := by
  -- To do (Oliver): complete proof
  sorry

/-
Original:
@[progress]
theorem IScalar.or_spec {ty} (x y : IScalar ty) :
  ∃ z, toResult (x ||| y) = ok z ∧ z.val = (x ||| y).val ∧ z.bv = x.bv||| y.bv
-/
@[spec]
theorem IScalar.or_spec' {ty} (x y : IScalar ty) :
    ⦃⌜True⌝⦄
    toResult (x ||| y)
    ⦃⇓z => ⌜z.val = (x ||| y).val ∧ z.bv = x.bv ||| y.bv⌝⦄ := by
  -- To do (Oliver): complete proof
  sorry

-- To do (Oliver): Shift operation specs are generated by macros (ShiftRight_spec, ShiftLeft_spec, etc.)

end Aeneas.Std
